# üìç Activity 01

## üìÖ Date: **February 14, 2025**  
## üìö Subject: **Software Engineering**  

### üóíÔ∏è Description  
1. Summarize the first excerpt from the book *Software Engineering at Google* (O'Reilly) in your own words.  
2. Summarize the second excerpt from the book *Software Engineering at Google* (O'Reilly) in your own words.  
3. List and explain three examples of **trade-offs** in software engineering.

---

## üìô Instructions

Good evening!

Please create a repository called **`bertoti`** -> folder **`engenhariadesoftware`** -> file **`readme.md`** and perform the following activities (comments will be added soon):

1. Comment on the first excerpt from the book *Software Engineering at Google, O‚ÄôReilly* (provided below) in your own words.  
2. Comment on the second excerpt from the book *Software Engineering at Google, O‚ÄôReilly* (provided below) in your own words.  
3. List and explain 3 examples of trade-offs.

---

## üìï Book *Software Engineering at Google*  

### üìç 1st Paragraph
> What precisely do we mean by software engineering? What distinguishes ‚Äúsoftware engineering‚Äù from ‚Äúprogramming‚Äù or ‚Äúcomputer science‚Äù? And why would Google have a unique perspective to add to the corpus of previous software engineering literature written over the past 50 years?
>
> The terms ‚Äúprogramming‚Äù and ‚Äúsoftware engineering‚Äù have been used interchangeably for quite some time in our industry, although each term has a different emphasis and different implications. University students tend to study computer science and get jobs writing code as ‚Äúprogrammers.‚Äù
>
> ‚ÄúSoftware engineering,‚Äù however, sounds more serious, as if it implies the application of some theoretical knowledge to build something real and precise. Mechanical engineers, civil engineers, aeronautical engineers, and those in other engineering disciplines all practice engineering. They all work in the real world and use the application of their theoretical knowledge to create something real. Software engineers also create ‚Äúsomething real,‚Äù though it is less tangible than the things other engineers create.
>
> Unlike those more established engineering professions, current software engineering theory or practice is not nearly as rigorous. Aeronautical engineers must follow rigid guidelines and practices, because errors in their calculations can cause real damage; programming, on the whole, has traditionally not followed such rigorous practices. But, as software becomes more integrated into our lives, we must adopt and rely on more rigorous engineering methods. We hope this book helps others see a path toward more reliable software practices.

### üìç 2nd Paragraph
> **Programming Over Time**  
> We propose that ‚Äúsoftware engineering‚Äù encompasses not just the act of writing code, but all of the tools and processes an organization uses to build and maintain that code over time. What practices can a software organization introduce that will best keep its code valuable over the long term? How can engineers make a codebase more sustainable and the software engineering discipline itself more rigorous? We don‚Äôt have fundamental answers to these questions, but we hope that Google‚Äôs collective experience over the past two decades illuminates possible paths toward finding those answers.
>
> One key insight we share in this book is that software engineering can be thought of as ‚Äúprogramming integrated over time.‚Äù What practices can we introduce to our code to make it sustainable‚Äîable to react to necessary change‚Äîover its life cycle, from conception to introduction to maintenance to deprecation?
>
> The book emphasizes three fundamental principles that we feel software organizations should keep in mind when designing, architecting, and writing their code:
>
> - **Time and Change**  
>   How code will need to adapt over the length of its life  
> - **Scale and Growth**  
>   How an organization will need to adapt as it evolves  
> - **Trade-offs and Costs**  
>   How an organization makes decisions, based on the lessons of Time and Change and Scale and Growth

---

## ‚úçüèª Answers  

1. **Comment on the first excerpt**  
   This excerpt draws a distinction between ‚Äúprogramming‚Äù and ‚Äúsoftware engineering.‚Äù Programming is generally associated with writing code based on theoretical knowledge acquired in computer science, while software engineering is seen as the application of more rigorous engineering principles‚Äîsimilar to mechanical or civil engineering‚Äîto build something real, though less tangible. The passage also underscores that software engineering has traditionally been less strict than other engineering fields, but as software becomes increasingly vital, the need for more rigorous engineering practices grows.

2. **Comment on the second excerpt**  
   This part emphasizes the long-term maintenance and evolution of code. Software engineering goes beyond just writing code, encompassing the tools and processes that keep it sustainable over time. The authors introduce the concept of ‚Äúprogramming integrated over time,‚Äù which highlights the importance of preparing software to handle inevitable changes throughout its lifecycle. They also point out three fundamental principles‚ÄîTime and Change, Scale and Growth, and Trade-offs and Costs‚Äîthat guide how organizations design, build, and maintain their code.

3. **Three examples of trade-offs in Software Engineering**  
   1. **Quality vs. Delivery Speed**  
      - *Explanation*: When under pressure to deliver quickly, the development team might compromise on testing or code quality. The trade-off lies between delivering a product faster or allocating more time to ensure higher-quality code.

   2. **Scalability vs. Complexity**  
      - *Explanation*: Architectures designed for massive scale (e.g., microservices) can handle significant load but also introduce complexity in deployment, monitoring, and maintenance. The trade-off is between building a simpler, easier-to-maintain system and constructing a more complex, highly scalable one.

   3. **Maintainability vs. Performance**  
      - *Explanation*: Highly optimized code can run faster but is often more complex and harder to understand. The trade-off here is between achieving peak performance or maintaining clearer, more easily adaptable code over time.
